{"version":3,"names":[],"mappings":"","sources":["all.js"],"sourcesContent":["const ccxt = require(\"ccxt\");\nconst fs = require(\"fs\");\npino_express = require(\"express-pino-logger\");\npino = require(\"pino\");\nvar inquirer = require(\"inquirer\");\nconst cluster = require(\"cluster\");\nvar path = require(\"path\");\nconst express = require(\"express\");\nconst app = express();\nvar rp = require(\"request-promise\");\nconst swaggerUi = require(\"swagger-ui-express\");\nswaggerDocument = require(\"./swagger.json\");\nvar compression = require(\"compression\");\nconst crypto = require(\"crypto\");\nvar rp = require(\"request-promise\");\nvar ajax = require(\"node.ajax\");\nconst { parse, stringify } = require(\"flatted/cjs\");\nconst options_swag = {\n  explorer: true,\n};\n\nparkersFunction = {};\n\nparkersFunction.getRequest = function (\n  url_main,\n  success_callback,\n  failure_callback,\n  method = \"GET\",\n  headers = undefined,\n  body = undefined\n) {\n  var options = {\n    uri: url_main,\n    /*qs: {\n            access_token: 'xxxxx xxxxx' // -> uri + '?access_token=xxxxx%20xxxxx'\n        },*/\n    /*headers: {\n            'User-Agent': 'Request-Promise'\n        },*/\n    json: true, // Automatically parses the JSON string in the response\n  };\n\n  try {\n    rp(options)\n      .then(function (json) {\n        //loggerPino.info(json);\n        success_callback(json);\n      })\n      .catch(function (err) {\n        loggerPino.error(err);\n        failure_callback(err);\n      });\n  } catch (e) {\n    loggerPino.error(e);\n    failure_callback(e);\n  }\n};\n\nparkersFunction.getRequestWithSignature = function (\n  url_base,\n  queryString,\n  success_callback,\n  failure_callback,\n  api_key,\n  method = \"GET\",\n  headers = undefined,\n  body = undefined,\n  secret = undefined\n) {\n  const hash = crypto\n    .createHmac(\"sha256\", secret)\n    .update(queryString)\n    .digest(\"hex\");\n\n  var options = {\n    uri: url_base + \"?\" + queryString + \"&signature=\" + hash,\n    /*qs: {\n            access_token: 'xxxxx xxxxx' // -> uri + '?access_token=xxxxx%20xxxxx'\n        },*/\n    headers: {\n      \"X-MBX-APIKEY\": api_key,\n    },\n    json: true, // Automatically parses the JSON string in the response\n  };\n\n  try {\n    rp(options)\n      .then(function (json) {\n        //loggerPino.info(json);\n        success_callback(json);\n      })\n      .catch(function (err) {\n        //console.log('catch error');\n        loggerPino.error(err);\n        failure_callback(err);\n      });\n  } catch (e) {\n    loggerPino.error(e);\n    failure_callback(e);\n  }\n};\n\nparkersFunction.getIsCoinPaymentID = function (result, error) {\n  this.getRequest(\n    \"https://api.hitbtc.com/api/2/public/currency\",\n    function (res) {\n      loggerPino.info(res);\n      result(res);\n    },\n    function (err) {\n      loggerPino.info(err);\n      error(err);\n    }\n  );\n};\n\nparkersFunction.getWithdrawFeeAndActive = function (\n  exchange,\n  currency = null,\n  withdrawOrDeposit = null,\n  amount = null,\n  api_key = null,\n  api_secret = null\n) {\n  switch (exchange) {\n    case \"binance\":\n      var promiseObj = new Promise(function (result, error) {\n        var timestamp = new Date().getTime();\n\n        parkersFunction.getRequestWithSignature(\n          \"https://api.binance.com/wapi/v3/assetDetail.html\",\n          \"timestamp=\" + timestamp + \"&recvWindow=5000\",\n          function (res) {\n            result(res);\n          },\n          function (err) {\n            error(err);\n          },\n          api_key,\n          \"GET\",\n          null,\n          null,\n          api_secret\n        );\n      });\n      return promiseObj;\n    case \"bittrex\":\n      var promiseObj = new Promise(function (result, error) {\n        parkersFunction.getRequest(\n          \"https://www.bittrex.com/api/v1.1/public/getCurrencies\",\n          function (res) {\n            result(res);\n          },\n          function (err) {\n            error(err);\n          }\n        );\n      });\n      return promiseObj;\n    case \"hitbtc\":\n      var promiseObj = new Promise(function (result, error) {\n        parkersFunction.getRequest(\n          \"https://api.hitbtc.com/api/2/public/currency\",\n          function (res) {\n            result(res);\n          },\n          function (err) {\n            error(err);\n          }\n        );\n      });\n      return promiseObj;\n    case \"anybits\":\n      var promiseObj = new Promise(function (result, error) {\n        parkersFunction.getRequest(\n          \"https://www.anybits.com/api/public/assets/currencies\",\n          function (res) {\n            result(res);\n          },\n          function (err) {\n            error(err);\n          }\n        );\n      });\n      return promiseObj;\n    case \"bitsane\":\n      var promiseObj = new Promise(function (result, error) {\n        parkersFunction.getRequest(\n          \"https://bitsane.com/api/public/assets/currencies\",\n          function (res) {\n            result(res);\n          },\n          function (err) {\n            error(err);\n          }\n        );\n      });\n      return promiseObj;\n    case \"bleutrade\":\n      var promiseObj = new Promise(function (result, error) {\n        parkersFunction.getRequest(\n          \"https://www.bleutrade.com/api/v2/public/getcurrencies\",\n          function (res) {\n            result(res);\n          },\n          function (err) {\n            error(err);\n          }\n        );\n      });\n      return promiseObj;\n    case \"buda\":\n      var promiseObj = new Promise(function (result, error) {\n        parkersFunction.getRequest(\n          \"https://www.buda.com/api/v2/currencies/\" +\n            currency +\n            \"/fees/\" +\n            withdrawOrDeposit,\n          function (res) {\n            result(res);\n          },\n          function (err) {\n            error(err);\n          }\n        );\n      });\n      return promiseObj;\n    case \"cobinhood\":\n      var promiseObj = new Promise(function (result, error) {\n        parkersFunction.getRequest(\n          \"https://api.cobinhood.com/v1/market/currencies\",\n          function (res) {\n            result(res);\n          },\n          function (err) {\n            error(err);\n          }\n        );\n      });\n      return promiseObj;\n    case \"crex24\":\n      var promiseObj = new Promise(function (result, error) {\n        parkersFunction.getRequest(\n          \"https://api.crex24.com/CryptoExchangeService/BotPublic/ReturnCurrencies\",\n          function (res) {\n            result(res);\n          },\n          function (err) {\n            error(err);\n          }\n        );\n      });\n      return promiseObj;\n    case \"kraken\":\n      var promiseObj = new Promise(function (result, error) {\n        parkersFunction.getRequest(\n          \"https://api.kraken.com/0/private/WithdrawInfo?asset=\" +\n            currency +\n            \"&key=\" +\n            key +\n            \"&amount=\" +\n            amount,\n          function (res) {\n            result(res);\n          },\n          function (err) {\n            error(err);\n          }\n        );\n      });\n      return promiseObj;\n    case \"livecoin\":\n      var promiseObj = new Promise(function (result, error) {\n        parkersFunction.getRequest(\n          \"https://api.livecoin.net/info/coininfo\",\n          function (res) {\n            result(res);\n          },\n          function (err) {\n            error(err);\n          }\n        );\n      });\n      return promiseObj;\n    case \"cryptopia\":\n      var promiseObj = new Promise(function (result, error) {\n        parkersFunction.getRequest(\n          \"https://www.cryptopia.co.nz/api/GetCurrencies\",\n          function (res) {\n            result(res);\n          },\n          function (err) {\n            error(err);\n          }\n        );\n      });\n      return promiseObj;\n    case \"poloniex\":\n      var promiseObj = new Promise(function (result, error) {\n        parkersFunction.getRequest(\n          \"https://poloniex.com/public?command=returnCurrencies\",\n          function (res) {\n            result(res);\n          },\n          function (err) {\n            error(err);\n          }\n        );\n      });\n      return promiseObj;\n  }\n\n  return promiseObj;\n};\n\nparkersFunction.parseData = function (exchange, info, currency) {\n  switch (exchange) {\n    case \"bittrex\":\n      return parseBittrexFees(info, currency);\n    case \"hitbtc\":\n      return parseHitbtcFees(info, currency);\n    case \"anybits\":\n      return parseAnybitFees(info, currency);\n    case \"bitsane\":\n      return parseBitsaneFees(info, currency);\n    case \"bleutrade\":\n      return parseBleuTradeFees(info, currency);\n    case \"buda\":\n      return parseBudaFees(info, currency);\n    case \"cobinhood\":\n      return parseCobinhoodFees(info, currency);\n    case \"crex24\":\n      return parseCrex24Fees(info, currency);\n    case \"kraken\":\n      return null; //this.getRequest(\"https://api.kraken.com/0/private/WithdrawInfo?asset=\" + currency + \"&key=\" + key + \"&amount=\" + amount)\n    case \"binance\":\n      return parseBinanceFees(info, currency);\n    case \"livecoin\":\n      return praseLiveCoinFees(info, currency);\n    case \"cryptopia\":\n      return parseCryptopiaFees(info, currency);\n    case \"poloniex\":\n      return parsePoloniexFees(info, currency);\n  }\n\n  function parsePoloniexFees(info, currency) {\n    try {\n      var ret = {\n        withdraw_min: 0,\n        withdraw_max: 0,\n        deposit_min: 0,\n        deposit_max: 0,\n        deposit_fee: 0,\n        withdraw_fee: \"string\",\n        symbol: \"string\",\n        paymentID: \"string\",\n\n        //this is for any feature that is apart of the arbitrage process does not work, it can one thing to a combination. ex: can not withdraw\n        isActive: true,\n      };\n\n      var inf = info[currency];\n      ret.withdraw_fee = inf.txFee;\n      if (inf.disabled == true) {\n        ret.isActive = false;\n      } else {\n        ret.isActive = true;\n      }\n      ret.symbol = currency;\n      return ret;\n    } catch (e) {\n      loggerPino.error(e);\n    }\n  }\n\n  function parseBinanceFees(info, currency) {\n    try {\n      var ret = {\n        withdraw_min: 0,\n        withdraw_max: 0,\n        deposit_min: 0,\n        deposit_max: 0,\n        deposit_fee: 0,\n        withdraw_fee: \"string\",\n        symbol: \"string\",\n        paymentID: \"string\",\n\n        //this is for any feature that is apart of the arbitrage process does not work, it can one thing to a combination. ex: can not withdraw\n        isActive: true,\n      };\n\n      var tradeFees = info.assetDetail;\n      var trueData = tradeFees[currency];\n\n      ret.minWithdrawAmount = trueData.minWithdrawAmount;\n      ret.deposit_frozen = trueData.depositStatus;\n      ret.withdraw_fee = trueData.withdrawFee.toString();\n\n      return ret;\n    } catch (e) {\n      loggerPino.error(e);\n      return null;\n    }\n  }\n\n  function parseCryptopiaFees(info, currency) {\n    try {\n      var ret = {\n        withdraw_min: 0,\n        withdraw_max: 0,\n        deposit_min: 0,\n        deposit_max: 0,\n        deposit_fee: 0,\n        withdraw_fee: \"string\",\n        symbol: \"string\",\n        paymentID: \"string\",\n\n        //this is for any feature that is apart of the arbitrage process does not work, it can one thing to a combination. ex: can not withdraw\n        isActive: true,\n      };\n      //console.log(info);\n      var currencies = info.Data;\n      var filtered_cryptopia_arr = currencies.filter(function (x) {\n        return x.Symbol == currency;\n      });\n      var filtered_cryptopia = filtered_cryptopia_arr[0];\n      //console.log(filtered_cryptopia)\n      ret.withdraw_fee = filtered_cryptopia.WithdrawFee;\n      ret.withdraw_max = filtered_cryptopia.MaxWithdraw;\n      ret.withdraw_min = filtered_cryptopia.MinWithdraw;\n      if (filtered_cryptopia.Status != \"OK\") {\n        ret.isActive = false;\n      } else {\n        ret.isActive = true;\n      }\n      ret.symbol = currency;\n\n      return ret;\n    } catch (e) {\n      loggerPino.error(e);\n      return null;\n    }\n  }\n\n  function parseCobinhoodFees(info, currency) {\n    try {\n      var ret = {\n        withdraw_min: 0,\n        withdraw_max: 0,\n        deposit_min: 0,\n        deposit_max: 0,\n        deposit_fee: 0,\n        withdraw_fee: \"string\",\n        symbol: \"string\",\n        paymentID: \"string\",\n\n        //this is for any feature that is apart of the arbitrage process does not work, it can one thing to a combination. ex: can not withdraw\n        isActive: true,\n      };\n\n      //console.log(JSON.stringify(info));\n\n      var currencies = info.result.currencies;\n      //console.log(currencies);\n      var filtered_cobinhood_arr = currencies.filter(function (x) {\n        return x.currency == currency;\n      });\n\n      var filtered_cobinhood = filtered_cobinhood_arr[0];\n      ret.symbol = currency;\n      ret.deposit_fee = filtered_cobinhood.deposit_fee;\n      ret.withdraw_fee = filtered_cobinhood.withdrawal_fee;\n      ret.withdraw_min = filtered_cobinhood.min_withdrawal;\n      if (\n        filtered_cobinhood.deposit_frozen ||\n        filtered_cobinhood.withdrawal_frozen\n      ) {\n        ret.isActive = false;\n      } else {\n        ret.isActive = true;\n      }\n\n      return ret;\n    } catch (e) {\n      loggerPino.error(e);\n      return null;\n    }\n  }\n\n  function parseBudaFees(info, currency) {\n    try {\n      var ret = {\n        withdraw_min: 0,\n        withdraw_max: 0,\n        deposit_min: 0,\n        deposit_max: 0,\n        deposit_fee: 0,\n        withdraw_fee: \"string\",\n        symbol: \"string\",\n        paymentID: \"string\",\n\n        //this is for any feature that is apart of the arbitrage process does not work, it can one thing to a combination. ex: can not withdraw\n        isActive: true,\n      };\n\n      var fees = info.fee;\n      if (fees.name == \"withdrawal\") {\n        ret.withdraw_fee = fees.base[0];\n      } else {\n        ret.deposit_fee = fees.base[0];\n      }\n      ret.symbol = currency;\n      return ret;\n    } catch (e) {\n      loggerPino.error(e);\n      return null;\n    }\n  }\n\n  function parseBleuTradeFees(info, currency) {\n    try {\n      var ret = {\n        withdraw_min: 0,\n        withdraw_max: 0,\n        deposit_min: 0,\n        deposit_max: 0,\n        deposit_fee: 0,\n        withdraw_fee: \"string\",\n        symbol: \"string\",\n        paymentID: \"string\",\n\n        //this is for any feature that is apart of the arbitrage process does not work, it can one thing to a combination. ex: can not withdraw\n        isActive: 0,\n      };\n      var results = info.result;\n      var filtered_bleutrade_arr = results.filter(function (x) {\n        return x.Currency == currency;\n      });\n      var filtered_bleutrade = filtered_bleutrade_arr[0];\n      ret.withdraw_fee = filtered_bleutrade.TxFee;\n      ret.isActive = filtered_bleutrade.isActive;\n      ret.symbol = currency;\n      return ret;\n    } catch (e) {\n      loggerpino.error(e);\n      return null;\n    }\n  }\n\n  function parseBittrexFees(info, currency) {\n    try {\n      var ret = {\n        withdraw_min: 0,\n        withdraw_max: 0,\n        deposit_min: 0,\n        deposit_max: 0,\n        deposit_fee: 0,\n        withdraw_fee: \"string\",\n        symbol: \"string\",\n        paymentID: \"string\",\n        isActive: 0,\n      };\n      //console.log(info);\n      //console.log(currency);\n      var results = info.result;\n      //console.log(\"info: \" + info);\n      var filtered_bittrex_arr = results.filter(function (x) {\n        return x.Currency == currency;\n      });\n\n      console.log(\"--------------------------------\");\n\n      var filtered_bittrex = filtered_bittrex_arr[0];\n      console.log(filtered_bittrex);\n      ret.withdraw_fee = filtered_bittrex.TxFee;\n      ret.isActive = filtered_bittrex.IsActive;\n      ret.symbol = currency;\n\n      return ret;\n    } catch (e) {\n      loggerPino.error(e);\n      return null;\n    }\n  }\n\n  function parseBitsaneFees(info, currency) {\n    try {\n      var ret = {\n        withdraw_min: 0,\n        withdraw_max: 0,\n        deposit_min: 0,\n        deposit_max: 0,\n        deposit_fee: 0,\n        withdraw_fee: \"string\",\n        symbol: \"string\",\n        paymentID: \"string\",\n\n        //this is for any feature that is apart of the arbitrage process does not work, it can one thing to a combination. ex: can not withdraw\n        isActive: 0,\n      };\n      var fees = info[currency];\n      console.log(fees);\n      ret.deposit_fee = fees.deposit_fee;\n      ret.withdraw_fee = fees.withdrawal_fee;\n      if (fees.deposit == false || fees.withdrawal == false) {\n        ret.isActive = false;\n      } else {\n        ret.isActive = true;\n      }\n\n      ret.symbol = currency;\n      return ret;\n    } catch (e) {\n      loggerPino.error(e);\n      return null;\n    }\n  }\n\n  function parseAnybitFees(info, currency) {\n    try {\n      var ret = {\n        withdraw_min: 0,\n        withdraw_max: 0,\n        deposit_min: 0,\n        deposit_max: 0,\n        deposit_fee: 0,\n        withdraw_fee: \"string\",\n        symbol: \"string\",\n        paymentID: \"string\",\n\n        //this is for any feature that is apart of the arbitrage process does not work, it can one thing to a combination. ex: can not withdraw\n        isActive: 0,\n      };\n      var fees = info[currency];\n      ret.deposit_fee = fees.deposit_fee;\n      ret.withdraw_fee = fees.withdrawal_fee;\n      if (fees.deposit == false || fees.withdrawal == false) {\n        ret.isActive = false;\n      } else {\n        ret.isActive = true;\n      }\n\n      ret.symbol = currency;\n      return ret;\n    } catch (e) {\n      loggerPino.error(e);\n      return null;\n    }\n  }\n\n  function parseHitbtcFees(info, currency) {\n    try {\n      var ret = {\n        withdraw_min: 0,\n        withdraw_max: 0,\n        deposit_min: 0,\n        deposit_max: 0,\n        deposit_fee: 0,\n        withdraw_fee: \"string\",\n        symbol: \"string\",\n        paymentID: \"string\",\n\n        //this is for any feature that is apart of the arbitrage process does not work, it can one thing to a combination. ex: can not withdraw\n        isActive: 0,\n      };\n\n      console.log(\"CURRENCY:\" + currency);\n\n      var filtered_hitbtc_arr = info.filter(function (x) {\n        return x.id == currency;\n      });\n\n      var filtered_hitbtc = filtered_hitbtc_arr[0];\n      console.log(filtered_hitbtc);\n\n      ret.symbol = filtered_hitbtc.id;\n      ret.withdraw_fee = filtered_hitbtc.payoutFee;\n\n      console.log(\"------------------------------------------------------\");\n      console.log(\"payout:\" + filtered_hitbtc.payoutEnabled);\n      console.log(\"payin:\" + filtered_hitbtc.payinEnabled);\n      console.log(\"delisted:\" + filtered_hitbtc.delisted);\n\n      console.log(\"payout var type:\" + typeof filtered_hitbtc.payoutEnabled);\n      console.log(\"-------------------------------------------------------\");\n\n      if (\n        filtered_hitbtc.payinEnabled == false ||\n        filtered_hitbtc.payoutEnabled == false ||\n        filtered_hitbtc.delisted == true\n      ) {\n        ret.isActive = false;\n      } else {\n        ret.isActive = true;\n      }\n\n      if (filtered_hitbtc.payoutIsPaymentId == true) {\n        ret.paymentID = filtered_hitbtc.payinPaymentId;\n      }\n\n      return ret;\n    } catch (e) {\n      loggerPino.error(e);\n      return null;\n    }\n  }\n\n  function parseCrex24Fees(info, currency) {\n    try {\n      var ret = {\n        withdraw_min: 0,\n        withdraw_max: 0,\n        deposit_min: 0,\n        deposit_max: 0,\n        deposit_fee: 0,\n        withdraw_fee: 0,\n        symbol: \"string\",\n\n        //this is for any feature that is apart of the arbitrage process does not work, it can one thing to a combination. ex: can not withdraw\n        isActive: 0,\n      };\n\n      var currencies = info.Currencies;\n      var filtered_crex24_arr = currencies.filter(function (x) {\n        return x.ShortName == currency;\n      });\n      var filtered_crex24 = filtered_crex24_arr[0];\n      //console.log(filtered_crex24_arr)\n      ret.symbol = filtered_crex24.ShortName;\n      if (\n        filtered_crex24.Disabled ||\n        filtered_crex24.Delisted ||\n        filtered_crex24.Frozen\n      ) {\n        ret.isActive = false;\n      } else {\n        ret.isActive = true;\n      }\n\n      ret.withdraw_fee = filtered_crex24.TxFee;\n      ret.withdraw_max = filtered_crex24.MaximumWithdraw;\n      ret.withdraw_min = filtered_crex24.MinimalWithdraw;\n      return ret;\n    } catch (e) {\n      loggerPino.error(e);\n      return null;\n    }\n  }\n\n  function praseLiveCoinFees(info, currency) {\n    try {\n      var ret = {\n        withdraw_min: 0,\n        withdraw_max: 0,\n        deposit_min: 0,\n        deposit_max: 0,\n        deposit_fee: 0,\n        withdraw_fee: 0,\n        symbol: \"string\",\n\n        //this is for any feature that is apart of the arbitrage process does not work, it can one thing to a combination. ex: can not withdraw\n        isActive: 0,\n      };\n      //console.log(\"============\");\n      //console.log(info)\n      //console.log(\"============\");\n      var infoArray = info.info;\n      //console.log(\"currency:\");\n      //console.log(currency);\n      //console.log(infoArray[0]);\n      var filtered_livecoin_arr = infoArray.filter(function (x) {\n        return x.symbol == currency;\n      });\n\n      var filtered_livecoin = filtered_livecoin_arr[0];\n      //console.log(\"array:-------\")\n      // console.log(filtered_livecoin_arr)\n      //console.log(\"-------------\")\n      ret.symbol = filtered_livecoin.symbol;\n      var wallet_status = filtered_livecoin.walletStatus;\n\n      var check = true;\n\n      switch (wallet_status) {\n        case \"delayed\":\n          check = false;\n          break;\n        case \"blocked\":\n          check = false;\n          break;\n        case \"blocked_long\":\n          check = false;\n          break;\n        case \"down\":\n          check = false;\n          break;\n        case \"delisted\":\n          check = false;\n          break;\n        case \"closed_cashin\":\n          check = false;\n          break;\n        case \"closed_cashout\":\n          check = false;\n          break;\n      }\n\n      ret.isActive = check;\n      ret.withdraw_fee = filtered_livecoin.withdrawFee;\n      ret.deposit_min = filtered_livecoin.minDepositAmount;\n      ret.withdraw_min = filtered_livecoin.minWithdrawAmount;\n      //no deposit fee\n\n      return ret;\n    } catch (e) {\n      loggerPino.error(e);\n      return null;\n    }\n  }\n};\n\nmodule.exports = parkersFunction;\n\nCryptoUtil = {};\n\nCryptoUtil.getCoinStatAvgPrices = function (skip, limit, success, fail) {\n  parkersFunction.getRequest(\n    \"https://api.coinstats.app/public/v1/coins?skip=\" +\n      skip +\n      \"&limit=\" +\n      limit,\n    function (json) {\n      success(json);\n    },\n    function (err) {\n      loggerPino.info(err);\n      fail(err);\n    },\n    \"GET\",\n    null,\n    null\n  );\n};\n\nCryptoUtil.getMarketsOfCoin = function (coin, success, fail) {\n  parkersFunction.getRequest(\n    \"https://api.coinstats.app/public/v1/markets?coinId=\" + coin,\n    success,\n    fail,\n    \"GET\",\n    null,\n    null\n  );\n};\n\nCryptoUtil.getNews = function (skip, limit, success, fail) {\n  parkersFunction.getRequest(\n    \"https://api.coinstats.app/public/v1/news?skip=\" + skip + \"&limit=\" + limit,\n    success,\n    fail,\n    \"GET\",\n    null,\n    null\n  );\n};\n\nCryptoUtil.getFiatCurrencies = function (success, fail) {\n  parkersFunction.getRequest(\n    \"https://api.coinstats.app/public/v1/fiats\",\n    success,\n    fail,\n    \"GET\",\n    null,\n    null\n  );\n};\n\nCryptoUtil.betterGetRequest = function (url, method, headers, body) {\n  parkersFunction.getRequest(\n    url,\n    function (json) {\n      return json;\n    },\n    function (err) {\n      return err;\n    },\n    method,\n    headers,\n    body\n  );\n};\n\nCryptoUtil.getCryptoPanicArticles = function (token, currency, success, fail) {\n  parkersFunction.getRequest(\n    \"https://cryptopanic.com/api/v1/posts/?auth_token=\" +\n      token +\n      \"&currencies=\" +\n      currency,\n    success,\n    fail,\n    \"GET\",\n    null,\n    null\n  );\n};\n\napp.use(\n  \"/api-docs\",\n  swaggerUi.serve,\n  swaggerUi.setup(swaggerDocument, options_swag)\n);\n\napp.use(compression()); // use compression\napp.use(express.static(path.join(__dirname, \"public\")));\nconst loggerPino = pino({\n  prettyPrint: {\n    colorize: true,\n  },\n});\n\nconst loggerPinoExpress = pino_express({\n  prettyPrint: {\n    colorize: true,\n  },\n});\n\nconst port = 3000;\n\napp.use(loggerPinoExpress);\n\nconst optimized = true;\nconst setEnableRateLimit = true;\n\nconst error = {\n  url: \"str\",\n  headers: {},\n  exception: null,\n  exchange: \"str\",\n  endpoint: \"str\",\n};\n\nserver = {};\n\nconst timeoutConst = 90000;\nasync function getExchange(\n  name,\n  apiKey,\n  apiSecret,\n  password,\n  uid,\n  marketSetPrice\n) {\n  try {\n    loggerPino.info(\"The exchange selected is \" + name);\n    switch (name) {\n      case \"binance\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.binance({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n            options: {\n              createMarketBuyOrderRequiresPrice: marketSetPrice,\n            },\n          });\n        } else {\n          return await new ccxt.binance({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n      case \"hitbtc\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.hitbtc({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.hitbtc({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n      case \"bittrex\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.bittrex({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n            options: {\n              createMarketBuyOrderRequiresPrice: marketSetPrice,\n            },\n          });\n        } else {\n          return await new ccxt.bittrex({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n      case \"bitfinex\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.bitfinex2({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.bitfinex2({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n      case \"kraken\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.kraken({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.kraken({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n      case \"theocean\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.theocean({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.theocean({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n      case \"upbit\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.upbit({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.upbit({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n      case \"acx\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.acx({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.acx({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n      case \"cex\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.cex({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.cex({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n      case \"bitstamp\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.bitstamp({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            uid: uid,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.bitstamp({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n      case \"bithumb\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.bithumb({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.bithumb({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n      case \"coinbase\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.coinbase({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.coinbase({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n      case \"coinbasepro\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.coinbasepro({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            password: password,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.coinbasepro({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n      case \"bcex\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.bcex({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.bcex({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n\n      case \"_1btcxe\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt._1btcxe({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt._1btcxe({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n\n      case \"anxpro\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.anxpro({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.anxpro({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n      case \"bibox\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.bibox({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.bibox({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n\n      case \"bigone\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.bigone({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.bigone({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n\n      case \"bit2c\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.bit2c({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.bit2c({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n\n      case \"bitbank\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.bitbank({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.bitbank({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n\n      case \"bitbay\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.bitbay({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.bitbay({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n\n      case \"bitflyer\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.bitflyer({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.bitflyer({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n\n      case \"bitforex\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.bitforex({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.bitforex({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n      case \"bitkk\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.bitkk({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.bitkk({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n\n      case \"bitlish\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.bitlish({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.bitlish({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n\n      case \"bitmarket\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.bitmarket({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.bitmarket({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n\n      case \"bitmex\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.bitmex({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.bitmex({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n      case \"bitso\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.bitso({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.bitso({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n\n      case \"bitz\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.bitz({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.bitz({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n\n      case \"bl3p\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.bl3p({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.bl3p({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n\n      case \"bleutrade\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.bleutrade({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.bleutrade({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n\n      case \"braziliex\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.braziliex({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.braziliex({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n\n      case \"btcalpha\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.btcalpha({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.btcalpha({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n\n      case \"btcbox\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.btcbox({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.btcbox({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n\n      case \"btcchina\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.btcchina({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.btcchina({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n      case \"btcmarkets\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.btcmarkets({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.btcmarkets({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n\n      case \"btctradeua\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.btctradeua({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.btctradeua({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n\n      case \"btcturk\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.btcturk({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.btcturk({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n\n      case \"buda\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.buda({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.buda({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n      case \"chilebit\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.chiebit({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.chilebit({\n            enableRateLimit: setEnableRateLimit,\n            timeout: timeoutConst,\n          });\n        }\n\n      case \"cobinhood\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.cobinhood({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: timeoutConst,\n          });\n        } else {\n          return await new ccxt.cobinhood({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 60000,\n          });\n        }\n\n      case \"coinbaseprime\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.coinbaseprime({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 60000,\n          });\n        } else {\n          return await new ccxt.coinbaseprime({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 60000,\n          });\n        }\n\n      case \"coincheck\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.coincheck({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 60000,\n          });\n        } else {\n          return await new ccxt.coincheck({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 60000,\n          });\n        }\n\n      case \"coinegg\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.coinegg({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 60000,\n          });\n        } else {\n          return await new ccxt.coinegg({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 60000,\n          });\n        }\n\n      case \"coinex\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.coinex({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 60000,\n          });\n        } else {\n          return await new ccxt.coinex({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 60000,\n          });\n        }\n\n      case \"coinfalcon\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.coinfalcon({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 60000,\n          });\n        } else {\n          return await new ccxt.coinfalcon({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 60000,\n          });\n        }\n\n      case \"coinfloor\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.coinfloor({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 60000,\n          });\n        } else {\n          return await new ccxt.coinfloor({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 60000,\n          });\n        }\n\n      case \"coingi\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.coingi({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 60000,\n          });\n        } else {\n          return await new ccxt.coingi({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 60000,\n          });\n        }\n\n      case \"coinmarketcap\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.coinmarketcap({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 60000,\n          });\n        } else {\n          return await new ccxt.coinmarketcap({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 60000,\n          });\n        }\n\n      case \"coinmate\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.coinmate({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 60000,\n          });\n        } else {\n          return await new ccxt.coinmate({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 60000,\n          });\n        }\n\n      case \"coinone\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.coinone({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 60000,\n          });\n        } else {\n          return await new ccxt.coinone({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 60000,\n          });\n        }\n\n      case \"coinspot\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.coinspot({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 60000,\n          });\n        } else {\n          return await new ccxt.coinspot({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 60000,\n          });\n        }\n\n      case \"cointiger\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.cointiger({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 60000,\n          });\n        } else {\n          return await new ccxt.cointiger({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 60000,\n          });\n        }\n\n      case \"coolcoin\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.coolcoin({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 60000,\n          });\n        } else {\n          return await new ccxt.coolcoin({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 60000,\n          });\n        }\n\n      case \"crex24\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.crex24({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 60000,\n          });\n        } else {\n          return await new ccxt.crex24({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 60000,\n          });\n        }\n\n      case \"dsx\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.dsx({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.dsx({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"exmo\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.exmo({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.exmo({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"exx\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.exx({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.exx({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"fcoin\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.fcoin({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.fcoin({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"flowbtc\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.flowbtc({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.flowbtc({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"foxbit\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.foxbit({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.foxbit({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"fybse\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.fybse({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.fybse({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"fybsg\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.fybsg({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.fybsg({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"gateio\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.gateio({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.gateio({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"gemini\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.gemini({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.gemini({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"hadax\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.hadax({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.hadax({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"huobipro\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.huobipro({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.huobipro({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"ice3x\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.ice3x({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.ice3x({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"independentreserve\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.independentreserve({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.independentreserve({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"indodax\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.indodax({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.indodax({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"itbit\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.itbit({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.itbit({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"kkex\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.kkex({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.kkex({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"kucoin\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.kucoin({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.kucoin({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"kuna\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.kuna({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.kuna({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"lakebtc\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.lakebtc({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.lakebtc({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"liqui\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.liqui({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.liqui({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"livecoin\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.livecoin({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.livecoin({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"luno\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.luno({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.luno({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"lykke\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.lykke({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.lykke({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"mercado\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.mercado({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.mercado({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"mixcoins\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.mixcoins({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.mixcoins({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"okcoinusd\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.okcoinusd({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.okcoinusd({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"okex\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.okex({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.okex({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"paymium\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.paymium({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.paymium({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"poloniex\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.poloniex({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n            nonce: function () {\n              return new Date().getTime();\n            },\n          });\n        } else {\n          return await new ccxt.poloniex({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n            nonce: function () {\n              return new Date().getTime();\n            },\n          });\n        }\n\n      case \"quoinex\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.quoinex({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.quoinex({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"rightbtc\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.rightbtc({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.rightbtc({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"southxchange\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.southxchange({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.southxchange({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"surbitcoin\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.surbitcoin({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.surbitcoin({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"therock\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.therock({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.therock({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"tidebit\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.tidebit({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.tidebit({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"tidex\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.tidex({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.tidex({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"vaultoro\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.vaultoro({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.vaultoro({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"vbtc\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.vbtc({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.vbtc({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"xbtce\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.xbtce({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.xbtce({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"yobit\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.yobit({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.yobit({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"zaif\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.zaif({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.zaif({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"zb\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.zb({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.zb({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"whitebit\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.whitebit({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.whitebit({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n      case \"topq\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.topq({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.topq({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"timex\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.timex({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.timex({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"stex\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.stex({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.stex({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"stronghold\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.stronghold({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.stronghold({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"oceanex\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.oceanex({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.oceanex({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"lbank\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.lbank({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.lbank({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"latoken\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.latoken({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.latoken({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"hollaex\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.hollaex({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.hollaex({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"fcoinjp\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.fcoinjp({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.fcoinjp({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"deribit\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.deribit({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.deribit({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"coss\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.coss({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.coss({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"bytetrade\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.bytetrade({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.bytetrade({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      case \"bybit\":\n        if (apiKey !== undefined && apiSecret !== undefined) {\n          return await new ccxt.bybit({\n            enableRateLimit: setEnableRateLimit,\n            apiKey: apiKey,\n            secret: apiSecret,\n            timeout: 40000,\n          });\n        } else {\n          return await new ccxt.bybit({\n            enableRateLimit: setEnableRateLimit,\n            timeout: 40000,\n          });\n        }\n\n      default:\n        // console.log(\"Did not find the exchange that was requested\");\n        return null;\n    }\n  } catch (e) {\n    console.log(e.stack);\n    return null;\n  }\n}\n\nfunction getCurrentDateTimeString() {\n  try {\n    let today = new Date();\n    let dd = today.getDate();\n    let mm = today.getMonth() + 1; // January is 0!\n    const yyyy = today.getFullYear();\n\n    if (dd < 10) {\n      dd = \"0\" + dd;\n    }\n\n    if (mm < 10) {\n      mm = \"0\" + mm;\n    }\n    const time = today.getTime();\n    today = mm + \"_\" + dd + \"_\" + yyyy + \"_\" + time;\n    return today;\n  } catch (e) {\n    console.log(e);\n    return \"errorGettingDate\";\n  }\n}\n\nfunction writeFile(filename, content, foldername) {\n  try {\n    if (!fs.existsSync(\"logs\")) {\n      fs.mkdirSync(\"logs\");\n    }\n    if (!fs.existsSync(\"logs\\\\\" + foldername)) {\n      fs.mkdirSync(\"logs\\\\\" + foldername);\n    }\n\n    var date = getCurrentDateTimeString();\n    filename = filename + date + \".txt\";\n    fs.writeFile(filename, content, function (err) {\n      if (err) {\n        return console.log(err);\n      }\n      loggerPino.error(\"LOGGED CALL FOR RECORDS\");\n    });\n  } catch (e) {\n    console.log(e);\n  }\n\n  date = getCurrentDateTimeString();\n  filename = filename + date + \".txt\";\n  fs.writeFile(filename, content, function (err) {\n    if (err) {\n      return console.log(err);\n    }\n    loggerPino.info(\"LOGGED CALL FOR RECORDS\");\n  });\n}\n\napp.get(\"/describe\", async (req, res) => {\n  // var headers = JSON.parse(req.headers.credentials)\n  try {\n    const exchange = await getExchange(req.query.exchange);\n\n    const desc = exchange.describe();\n    // req.log.info(desc);\n    res.json(desc);\n  } catch (e) {\n    console.log(\"-------------------------\");\n    req.log.error(e.stack);\n    console.log(\"-------------------------\");\n    const error = {\n      error: true,\n      message: e,\n      stack: e.stack,\n    };\n    res.json(error);\n  }\n});\n\n// localhost/getOrderBook?exchange={}&symbol={}\napp.get(\"/getOrderBook\", async (req, res) => {\n  try {\n    const exchange = await getExchange(req.query.exchange);\n    exchange.enableRateLimit = true;\n    const symbol = req.query.symbol;\n    const orderBooks = await exchange.fetchOrderBook(symbol);\n\n    res.json(orderBooks);\n  } catch (e) {\n    const error = {\n      error: true,\n      message: e,\n      stack: e.stack,\n    };\n    res.json(error);\n    console.log(\"-------------------------\");\n    req.log.error(e.stack);\n    console.log(\"-------------------------\");\n  }\n});\n\napp.get(\"/ListOfExchanges\", async (req, res) => {\n  const exchanges = [\n    \"_1btcxe\",\n    \"acx\",\n    \"adara\",\n    \"anxpro\",\n    \"aofex\",\n    \"bcex\",\n    \"bequant\",\n    \"bibox\",\n    \"bigone\",\n    \"binance\",\n    \"binanceje\",\n    \"binanceus\",\n    \"bit2c\",\n    \"bitbank\",\n    \"bitbay\",\n    \"bitfinex2\",\n    \"bitflyer\",\n    \"bitforex\",\n    \"bithumb\",\n    \"bitkk\",\n    \"bitlish\",\n    \"bitmart\",\n    \"bitmax\",\n    \"bitmex\",\n    \"bitso\",\n    \"bitstamp\",\n    \"bittrex\",\n    \"bitz\",\n    \"bl3p\",\n    \"bleutrade\",\n    \"braziliex\",\n    \"btcalpha\",\n    \"btcbox\",\n    \"btcmarkets\",\n    \"btctradeim\",\n    \"btctradeua\",\n    \"btcturk\",\n    \"buda\",\n    \"bw\",\n    \"bybit\",\n    \"bytetrade\",\n    \"cex\",\n    \"chilebit\",\n    \"cobinhood\",\n    \"coinbase\",\n    \"coinbaseprime\",\n    \"coinbasepro\",\n    \"coincheck\",\n    \"coinegg\",\n    \"coinex\",\n    \"coinfalcon\",\n    \"coinfloor\",\n    \"coingi\",\n    \"coinmarketcap\",\n    \"coinmate\",\n    \"coinone\",\n    \"coinspot\",\n    \"coolcoin\",\n    \"coss\",\n    \"crex24\",\n    \"deribit\",\n    \"digifinex\",\n    \"dsx\",\n    \"exmo\",\n    \"exx\",\n    \"fcoin\",\n    \"fcoinjp\",\n    \"flowbtc\",\n    \"foxbit\",\n    \"ftx\",\n    \"fybse\",\n    \"gateio\",\n    \"gemini\",\n    \"hitbtc\",\n    \"hollaex\",\n    \"huobipro\",\n    \"huobiru\",\n    \"ice3x\",\n    \"idex\",\n    \"independentreserve\",\n    \"indodax\",\n    \"itbit\",\n    \"kkex\",\n    \"kraken\",\n    \"kucoin\",\n    \"kuna\",\n    \"lakebtc\",\n    \"latoken\",\n    \"lbank\",\n    \"liquid\",\n    \"livecoin\",\n    \"luno\",\n    \"lykke\",\n    \"mercado\",\n    \"mixcoins\",\n    \"oceanex\",\n    \"okcoin\",\n    \"okex\",\n    \"paymium\",\n    \"poloniex\",\n    \"rightbtc\",\n    \"southxchange\",\n    \"stex\",\n    \"stronghold\",\n    \"surbitcoin\",\n    \"theocean\",\n    \"therock\",\n    \"tidebit\",\n    \"tidex\",\n    \"timex\",\n    \"topq\",\n    \"upbit\",\n    \"vaultoro\",\n    \"VBTC\",\n    \"whitebit\",\n    \"xbtce\",\n    \"yobit\",\n    \"zaif\",\n    \"zb\",\n  ];\n\n  res.json(exchanges);\n});\n\napp.get(\"/transferMainToTrade\", async (req, res) => {\n  try {\n    const headers = JSON.parse(req.headers.credentials);\n    const symbol = req.query.symbol;\n    const amount = req.headers.amount;\n    const api_key = headers.apiKey;\n    const api_secret = headers.apiSecret;\n    const exchange = await getExchange(\n      req.query.exchange,\n      api_key.trim(),\n      api_secret.trim()\n    );\n\n    exchange.enableRateLimit = true;\n    if (exchange !== null || exchange !== undefined) {\n      exchange.private_post_account_transfer({\n        currency: symbol,\n        amount: parseFloat(amount),\n        type: \"bankToExchange\",\n      });\n      res.json({\n        success: true,\n      });\n    } else {\n      var error = {\n        error: true,\n        message: \"could not get exchange\",\n        stack: \"-\",\n      };\n      console.log(\"-------------------------\");\n      req.log.error(\"could not get exchange\");\n      console.log(\"-------------------------\");\n      res.json(error);\n    }\n  } catch (e) {\n    error = {\n      error: true,\n      message: e,\n      stack: e.stack,\n    };\n    res.json(error);\n    console.log(\"-------------------------\");\n    req.log.error(e.stack);\n    console.log(\"-------------------------\");\n  }\n});\n\napp.get(\"/transferTradeToMain\", async (req, res) => {\n  try {\n    const headers = JSON.parse(req.headers.credentials);\n    const symbol = req.query.symbol;\n    const amount = req.headers.amount;\n    const api_key = headers.apiKey;\n    const api_secret = headers.apiSecret;\n    const exchange = await getExchange(\n      req.query.exchange,\n      api_key.trim(),\n      api_secret.trim()\n    );\n    exchange.enableRateLimit = true;\n    if (exchange !== null && exchange !== undefined) {\n      exchange.private_post_account_transfer({\n        currency: symbol,\n        amount: parseFloat(amount),\n        type: \"exchangeToBank\",\n      });\n      res.json({\n        success: true,\n      });\n    } else {\n      var error = {\n        error: true,\n        message: \"not able to get exchange\",\n        stack: \"-\",\n      };\n      console.log(\"-------------------------\");\n      req.log.error(error);\n      console.log(\"-------------------------\");\n      res.json(error);\n    }\n  } catch (e) {\n    error = {\n      error: true,\n      message: e,\n      stack: e.stack,\n    };\n    console.log(\"-------------------------\");\n    req.log.error(e.stack);\n    console.log(\"-------------------------\");\n    req.log.info(e);\n    res.json(error);\n  }\n});\n\n// localhost/balance?exchange={}\napp.get(\"/balance\", async (req, res) => {\n  try {\n    const headers = JSON.parse(req.headers.credentials);\n\n    const api_key = headers.apiKey;\n    const api_secret = headers.apiSecret;\n\n    const _type = req.query.type;\n    const currency = req.query.currency;\n    let exchange;\n    console.log(req.query.exchange);\n    console.log(headers);\n    if (headers.password === undefined) {\n      if (headers.uid === undefined) {\n        exchange = await getExchange(\n          req.query.exchange,\n          api_key.trim(),\n          api_secret.trim()\n        );\n      } else {\n        exchange = await getExchange(\n          req.query.exchange,\n          api_key.trim(),\n          api_secret.trim(),\n          null,\n          headers.uid.trim()\n        );\n      }\n    } else {\n      exchange = await getExchange(\n        req.query.exchange,\n        api_key.trim(),\n        api_secret.trim(),\n        headers.password.trim()\n      );\n    }\n\n    let balance = null;\n    if (_type !== undefined) {\n      balance = await exchange.fetchBalance({\n        type: _type,\n      });\n    } else {\n      balance = await exchange.fetchBalance();\n    }\n    console.log(\"balance: \", balance);\n    const bal_ret = parseBalance(balance, req.query.exchange, currency);\n\n    if (!optimized) {\n      writeFile(\n        \"logs\\\\getBalance\\\\getBalance\",\n        JSON.stringify(bal_ret),\n        \"getBalance\"\n      );\n    }\n\n    res.json(bal_ret);\n  } catch (e) {\n    console.log(\"-------------------------\");\n    req.log.error(e.stack);\n    console.log(\"-------------------------\");\n    writeFile(\"logs\\\\errorBalance\\\\errorBalance.txt\", e);\n    const error = {\n      error: true,\n      message: e,\n      stack: e.stack,\n    };\n    res.json(error);\n  }\n});\n\napp.get(\"/cancelOrder\", async (req, res) => {\n  try {\n    const headers = JSON.parse(req.headers.credentials);\n    const tradeID = req.query.id;\n    let exchange;\n    if (headers.password === undefined) {\n      if (headers.uid === undefined) {\n        exchange = await getExchange(\n          req.query.exchange,\n          headers.apiKey.trim(),\n          headers.apiSecret.trim()\n        );\n      } else {\n        exchange = await getExchange(\n          req.query.exchange,\n          headers.apiKey.trim(),\n          headers.apiSecret.trim(),\n          null,\n          headers.uid.trim()\n        );\n      }\n    } else {\n      exchange = await getExchange(\n        req.query.exchange,\n        headers.apiKey.trim(),\n        headers.apiSecret.trim(),\n        headers.password.trim()\n      );\n    }\n    exchange.enableRateLimit = true;\n\n    const cancel = await exchange.cancelOrder(tradeID);\n    // req.log.info(cancel);\n    res.json(cancel);\n  } catch (e) {\n    req.log.error(e);\n    writeFile(\n      \"logs\\\\errorCancelOrder\\\\errorCancelOrder\",\n      e,\n      \"errorCancelOrder\"\n    );\n    const error = {\n      error: true,\n      message: e,\n    };\n    res.json(error);\n  }\n});\n\napp.get(\"/withdrawDepositHistory\", async (req, res) => {\n  try {\n    const headers = JSON.parse(req.headers.credentials);\n    const exchangeName = req.query.exchange;\n    let exchange;\n    if (headers.password === undefined) {\n      if (headers.uid === undefined) {\n        exchange = await getExchange(\n          exchangeName,\n          headers.apiKey.trim(),\n          headers.apiSecret.trim()\n        );\n      } else {\n        exchange = await getExchange(\n          exchangeName,\n          headers.apiKey.trim(),\n          headers.apiSecret.trim(),\n          null,\n          headers.uid.trim()\n        );\n      }\n    } else {\n      exchange = await getExchange(\n        exchangeName,\n        headers.apiKey,\n        headers.apiSecret,\n        headers.password.trim()\n      );\n    }\n    exchange.enableRateLimit = true;\n    const with_history = await exchange.fetchWithdrawals();\n    const dep_histroy = await exchange.fetchDeposits();\n    const withDepHist = {\n      withdraw: with_history,\n      deposit: dep_histroy,\n    };\n\n    // req.log.info(withDepHist);\n    res.json(withDepHist);\n  } catch (e) {\n    req.log.error(e);\n    writeFile(\n      \"logs\\\\errorWithdrawDepositHist\\\\errorWithdrawDepositHist\",\n      e,\n      \"errorWithdrawDepositHist\"\n    );\n    const error = {\n      error: true,\n      message: e,\n    };\n    res.json(error);\n  }\n});\n\n// localhost/order?exchange={}&side={}&type={}&symbol={}&price={}&quantity={}\napp.get(\"/order\", async (req, res) => {\n  // var price_quantity_data = JSON.parse(req.headers.priceQuantity)\n  try {\n    const headers = JSON.parse(req.headers.credentials);\n    const tradeID = req.headers.tradeID;\n    const marketPrice = req.query.setMarketPrice;\n    var checkPrice = false;\n    if (marketPrice === \"true\") {\n      checkPrice = true;\n    }\n    let exchange;\n    if (headers.password === undefined) {\n      if (headers.uid === undefined) {\n        exchange = await getExchange(\n          req.query.exchange,\n          headers.apiKey.trim(),\n          headers.apiSecret.trim(),\n          null,\n          null,\n          checkPrice\n        );\n      } else {\n        exchange = await getExchange(\n          req.query.exchange,\n          headers.apiKey.trim(),\n          headers.apiSecret.trim(),\n          null,\n          headers.uid.trim(),\n          checkPrice\n        );\n      }\n    } else {\n      exchange = await getExchange(\n        req.query.exchange,\n        headers.apiKey,\n        headers.apiSecret,\n        headers.password.trim(),\n        null,\n        checkPrice\n      );\n    }\n    exchange.enableRateLimit = true;\n    if (exchange !== null || exchange !== undefined) {\n      const quantity = req.headers.quantity;\n      const price = req.headers.price;\n\n      const timeInForce = req.headers.timeInForce;\n\n      let order;\n      if (timeInForce === null) {\n        if (checkPrice === true && req.query.type === \"market\") {\n          order = await exchange.createOrder(\n            req.query.quoteCur + \"/\" + req.query.baseCur,\n            req.query.type,\n            req.query.side,\n            quantity,\n            price\n          );\n        } else {\n          order = await exchange.createOrder(\n            req.query.quoteCur + \"/\" + req.query.baseCur,\n            req.query.type,\n            req.query.side,\n            quantity,\n            price\n          );\n        }\n\n        // req.log.info(order);\n        if (!optimized) {\n          writeFile(\n            \"logs\\\\performOrder\\\\performOrder\",\n            JSON.stringify(order) + \"     timeInForce: \" + timeInForce,\n            \"performOrder\"\n          );\n        }\n      } else {\n        order = await exchange.createOrder(\n          req.query.quoteCur + \"/\" + req.query.baseCur,\n          req.query.type,\n          req.query.side,\n          quantity,\n          price,\n          {\n            timeInForce: timeInForce,\n          }\n        );\n        // req.log.info(order);\n        if (!optimized) {\n          writeFile(\n            \"logs\\\\performOrder\\\\performOrder\",\n            JSON.stringify(order) + \"     timeInForce: \" + timeInForce,\n            \"performOrder\"\n          );\n        }\n      }\n\n      res.json(order);\n    } else {\n      var error = {\n        error: true,\n        message: \"not able to get exchange\",\n        stack: \"-\",\n      };\n      console.log(\"-------------------------\");\n      req.log.error(error);\n      console.log(\"-------------------------\");\n      res.json(error);\n    }\n  } catch (e) {\n    console.log(\"-------------------------\");\n    req.log.error(e.stack);\n    console.log(\"-------------------------\");\n    writeFile(\"logs\\\\errorOrder\\\\errorOrder\", e, \"errorOrder\");\n    error = {\n      error: true,\n      message: e,\n      stack: e.stack,\n    };\n    res.json(error);\n  }\n});\n\n// localhost/cancelOrder?exchange={}&id={}\n/* app.get('/performWithdraw', async (req, res, next) => {\n    var headers = JSON.parse(req.headers.credentials)\n    try {\n        var exchange = getExchange(req.query.exchange)\n        var order = await exchange.withdraw(headers.id)\n        console.log(order)\n        res.json(order)\n    } catch (e) {\n        //TODO handle the error\n        next(e)\n    }\n}) */\n\n// localhost/getOpenOrders?exchange={}&symbol={}\napp.get(\"/getOpenOrders\", async (req, res) => {\n  try {\n    const headers = JSON.parse(req.headers.credentials);\n    let exchange;\n    if (headers.password === undefined) {\n      if (headers.uid === undefined) {\n        exchange = await getExchange(\n          req.query.exchange,\n          headers.apiKey.trim(),\n          headers.apiSecret.trim()\n        );\n      } else {\n        exchange = await getExchange(\n          req.query.exchange,\n          headers.apiKey.trim(),\n          headers.apiSecret.trim(),\n          null,\n          headers.uid.trim()\n        );\n      }\n    } else {\n      exchange = await getExchange(\n        req.query.exchange,\n        headers.apiKey,\n        headers.apiSecret,\n        headers.password.trim()\n      );\n    }\n    if (exchange !== null || exchange !== undefined) {\n      const tradeID = req.headers.tradeID;\n      const symbolBase = req.query.symbolBase;\n      const symbolQuote = req.query.symbolQuote;\n      /* var order = await exchange.fetchOpenOrders(req.query.baseCur + \"/\" + req.query.quoteCur)\n                    console.log(order)\n                    res.json(order) */\n\n      console.log(exchange);\n      // if (exchange.has['fetchOpenOrders']) {\n      const since = exchange.milliseconds(); // -1 day from now\n      // alternatively, fetch from a certain starting datetime\n      // let since = exchange.parse8601 ('2018-01-01T00:00:00Z')\n      const allTrades = [];\n\n      const limit = 20; // change for your limit\n      let trades;\n      if (symbolBase === undefined && symbolQuote === undefined) {\n        trades = await exchange.fetchOpenOrders(); // symbol, since, limit)\n      } else {\n        trades = await exchange.fetchOpenOrders(symbolBase + \"/\" + symbolQuote); // symbol, since, limit)\n      }\n\n      // req.log.info(trades);\n      if (!optimized) {\n        writeFile(\n          \"logs\\\\getOpenOrders\\\\getOpenOrders\",\n          trades,\n          \"getOpenOrders\"\n        );\n      }\n      res.json(trades);\n\n      // }\n      req.log.info(\"has fetchOpenOrders: \" + exchange.has.fetchOpenOrders);\n    } else {\n      var error = {\n        error: true,\n        message: \"not able to get exchange\",\n        stack: \"-\",\n      };\n      console.log(\"-------------------------\");\n      req.log.error(error);\n      console.log(\"-------------------------\");\n      res.json(error);\n    }\n  } catch (e) {\n    req.log.error(e);\n    writeFile(\"logs\\\\errorOpenOrders\\\\errorOpenOrders\", e, \"errorOpenOrders\");\n    error = {\n      error: true,\n      message: e,\n      stack: e.stack,\n    };\n    res.json(error);\n  }\n});\n\n// localhost/getOpenOrders?exchange={}&symbol={}\napp.get(\"/getTickerData\", async (req, res) => {\n  try {\n    const exchange = await getExchange(req.query.exchange);\n    if (exchange !== null || exchange !== undefined) {\n      const base_cur = req.query.baseCur;\n      const quote_cur = req.query.quoteCur;\n\n      console.log(\"base currency: \" + base_cur);\n      console.log(\"quote currency:\" + quote_cur);\n      let ticker = null;\n\n      ticker = await exchange.fetchTicker(base_cur + \"/\" + quote_cur);\n\n      if (!optimized) {\n        writeFile(\n          \"logs\\\\getTickerData\\\\getTickerData\",\n          JSON.stringify(ticker),\n          \"getTickerData\"\n        );\n      }\n      res.json(ticker);\n    } else {\n      var error = {\n        error: true,\n        message: \"not able to get exchange\",\n        stack: \"-\",\n      };\n      console.log(\"-------------------------\");\n      req.log.error(error);\n      console.log(\"-------------------------\");\n      res.json(error);\n    }\n  } catch (e) {\n    req.log.error(e);\n\n    writeFile(\"logs\\\\errorTickerData\\\\errorTickerData\", e, \"errorTickerData\");\n    error = {\n      error: true,\n      message: e,\n      stack: e.stack,\n    };\n    res.json(error);\n    // next(e)\n  }\n});\n\n// localhost/getOrders?exchange={}&symbol={}\napp.get(\"/getOrders\", async (req, res) => {\n  try {\n    const headers = JSON.parse(req.headers.credentials);\n    let exchange;\n    if (headers.password === undefined) {\n      if (headers.uid === undefined) {\n        exchange = await getExchange(\n          req.query.exchange,\n          headers.apiKey.trim(),\n          headers.apiSecret.trim()\n        );\n      } else {\n        exchange = await getExchange(\n          req.query.exchange,\n          headers.apiKey.trim(),\n          headers.apiSecret.trim(),\n          null,\n          headers.uid.trim()\n        );\n      }\n    } else {\n      exchange = await getExchange(\n        req.query.exchange,\n        headers.apiKey,\n        headers.apiSecret,\n        headers.password.trim()\n      );\n    }\n    const order = await exchange.fetchOrders(headers.symbol.replace(\"-\", \"/\"));\n    // req.log.info(order);\n    res.json(order);\n  } catch (e) {\n    console.log(\"-------------------------\");\n    req.log.error(e.stack);\n    console.log(\"-------------------------\");\n    // TODO handle the error\n    const error = {\n      error: true,\n      message: e,\n      stack: e.stack,\n    };\n    res.json(error);\n    // next(e)\n  }\n});\n\napp.get(\"/getOHLCV\", async (req, res) => {\n  try {\n    // var headers = JSON.parse(req.headers.credentials);\n    const baseCur = req.query.baseCur;\n    const quoteCur = req.query.quoteCur;\n    const timeFrame = req.query.timeframe;\n    const exchange = await getExchange(req.query.exchange);\n    const OHLCV = await exchange.fetchOHLCV(\n      baseCur + \"/\" + quoteCur,\n      timeFrame\n    );\n\n    const index = 0;\n    const final = [];\n\n    // var arr = OHLCV[0]\n    // console.log(\"------------------------------------------------------------\");\n    const plus = {\n      timestamp: [],\n      openPrice: [],\n      highPrice: [],\n      lowPrice: [],\n      closePrice: [],\n      volume: [],\n    };\n    for (var xx in OHLCV) {\n      const hist = OHLCV[xx];\n\n      for (var x in hist) {\n        const dat = hist[x];\n        // console.log(x);\n        switch (x) {\n          case \"0\":\n            plus.timestamp.push(dat);\n\n            break;\n\n          case \"1\":\n            plus.openPrice.push(dat);\n\n            break;\n\n          case \"2\":\n            plus.highPrice.push(dat);\n\n            break;\n\n          case \"3\":\n            plus.lowPrice.push(dat);\n\n            break;\n\n          case \"4\":\n            plus.closePrice.push(dat);\n\n            break;\n\n          case \"5\":\n            plus.volume.push(dat);\n\n            break;\n        }\n      }\n    }\n    res.json(plus);\n  } catch (e) {\n    req.log.error(e);\n    const error = {\n      error: true,\n      message: e,\n    };\n    res.json(error);\n  }\n});\n\nprocess.on(\"uncaughtException\", function (err) {\n  try {\n    console.log(\"//////////////////////////////////////////////////////\");\n    console.log(new Date().toUTCString() + \" uncaught Exception: \");\n    console.log(err);\n    fs.writeSync(1, `Caught exception: ${err}\\n`);\n    console.log(\"//////////////////////////////////////////////////////\");\n    writeFile(\"logs\\\\crashLog\\\\crashLog\", err, \"crashLog\");\n    process.exit(1);\n  } catch (e) {\n    process.exit(1);\n  }\n});\n\nprocess.on(\"warning\", (warning) => {\n  console.warn(warning.name); // Print the warning name\n  console.warn(warning.message); // Print the warning message\n  console.warn(warning.stack); // Print the stack trace\n});\n\nprocess.on(\"unhandledRejection\", (reason, p) => {\n  console.log(\"Unhandled Rejection at:\", p, \"reason:\", reason);\n  // Application specific logging, throwing an error, or other logic here\n});\n\napp.get(\"/getMinMaxTradeAmount\", async (req, res) => {\n  try {\n    const baseCur = req.query.baseCur;\n    const quoteCur = req.query.quoteCur;\n    const exchangeName = req.query.exchange;\n    const exchange = await getExchange(exchangeName);\n\n    const mrks = await exchange.fetchMarkets();\n    const filteredMrk = mrks.filter(function (x) {\n      return x.symbol === baseCur + \"/\" + quoteCur;\n    });\n    const f = filteredMrk[0];\n\n    // req.log.info(f);\n\n    console.log(f);\n    console.log(\"------------\");\n\n    var min_max = null;\n    if (exchangeName === \"binance\") {\n      min_max = {\n        amount_min: f.limits.amount.min,\n        // amount_max: filteredMrk.limits.amount.max,\n        price_min: f.limits.price.min,\n        // price_max: filteredMrk.limits.price.max,\n        cost_min: f.limits.cost.min,\n        // cost_max: filteredMrk.limits.cost.max,\n        symbol: baseCur + \"/\" + quoteCur,\n        baseCur: baseCur,\n        quoteCur: quoteCur,\n        exchange: exchangeName,\n      };\n    }\n\n    if (exchangeName === \"hitbtc\") {\n      min_max = {\n        amount_min: f.limits.amount.min,\n        // amount_max: filteredMrk.limits.amount.max,\n        price_min: f.limits.price.min,\n        // price_max: filteredMrk.limits.price.max,\n        cost_min: f.limits.cost.min,\n        // cost_max: filteredMrk.limits.cost.max,\n        symbol: baseCur + \"/\" + quoteCur,\n        baseCur: baseCur,\n        quoteCur: quoteCur,\n        exchange: exchangeName,\n      };\n    }\n\n    if (exchangeName === \"bittrex\") {\n      min_max = {\n        amount_min: f.limits.amount.min,\n        // amount_max: filteredMrk.limits.amount.max,\n        price_min: f.limits.price.min,\n        // price_max: filteredMrk.limits.price.max,\n        cost_min: 0,\n        // cost_max: filteredMrk.limits.cost.max,\n        symbol: baseCur + \"/\" + quoteCur,\n        baseCur: baseCur,\n        quoteCur: quoteCur,\n        exchange: exchangeName,\n      };\n    }\n\n    // req.log.info(min_max);\n    res.json(min_max);\n  } catch (e) {\n    console.log(\"-------------------------\");\n    req.log.error(e.stack);\n    console.log(\"-------------------------\");\n    const error = {\n      error: true,\n      message: e,\n    };\n    res.json(error);\n  }\n});\n\napp.get(\"/getTradeHistory\", async (req, res) => {\n  try {\n    const exchangeName = req.query.exchange;\n    const symbol = req.query.symbol;\n\n    const headers = JSON.parse(req.headers.credentials);\n    const dateReq = headers.date;\n    let exchange;\n    if (headers.password === undefined) {\n      if (headers.uid === undefined) {\n        exchange = await getExchange(\n          exchangeName,\n          headers.apiKey.trim(),\n          headers.apiSecret.trim()\n        );\n      } else {\n        exchange = await getExchange(\n          exchangeName,\n          headers.apiKey.trim(),\n          headers.apiSecret.trim(),\n          null,\n          headers.uid.trim()\n        );\n      }\n    } else {\n      exchange = await getExchange(\n        exchangeName,\n        headers.apiKey,\n        headers.apiSecret,\n        headers.password.trim()\n      );\n    }\n\n    // var trades = await exchange.fetchTrades(symbol);\n    let date;\n    if (dateReq === undefined) {\n      date = new Date(\"5/23/2017\");\n    } else {\n      date = new Date(dateReq);\n    }\n    console.log(\"date: \" + date);\n    const trades = await exchange.fetchTrades(\n      symbol,\n      date.getMilliseconds(),\n      1000\n    );\n    const tradeRet = {\n      tradeData: trades,\n    };\n    // req.log.info(tradeRet);\n    res.json(tradeRet);\n  } catch (e) {\n    req.log.error(e);\n    const error = {\n      error: true,\n      message: e,\n    };\n    res.json(error);\n  }\n});\n\n// localhost/getExchangeTradeFees?exchange={}\napp.get(\"/getExchangeTradeFees\", async (req, res, next) => {\n  var fees = {\n    hitbtc: \"0.1\",\n    bittrex: \"0.25\",\n    poloniex: \"0.2\",\n    cobinhood: \"0.0\",\n    binance: \"0.1\",\n    anybits: \"0.25\",\n    bitsane: \"0.2\",\n    bleutrade: \"0.25\",\n    buda: \"0.8\",\n    crex24: \"0.1\",\n    livecoin: \"0.18\",\n    kraken: \"0.26\",\n    percentages: true,\n  };\n  res.json(fees);\n  /* try {\n      // var symbol = req.query.symbol;\n      const baseCur = req.query.baseCur\n      const quoteCur = req.query.quoteCur\n      const exchangeName = req.query.exchange\n      const exchange = await getExchange(exchangeName)\n      if (exchange !== null && exchange !== undefined) {\n        const check = exchange.describe().has.fetchTradingFees\n\n        if (check === true) {\n          try {\n            var fee = await exchange.fetchTradingFees()\n            // req.log.info(\"trading fee:\");\n            // req.log.info(fee);\n            res.json(fee)\n          } catch (e) {\n\n            // req.log.info(fee);\n\n          }\n        } else {\n          try {\n            const mark = await exchange.fetchMarkets()\n            const filteredMrk = mark.filter(function (x) {\n              return x.symbol === baseCur + '/' + quoteCur\n            })\n\n            // req.log.error(filteredMrk);\n\n            const taker_maker = {\n              taker: filteredMrk['0'].taker,\n              maker: filteredMrk['0'].maker\n            }\n\n            if (taker_maker.maker !== undefined && taker_maker.maker !== null && taker_maker.maker !== '') {\n              fees = {\n                percentages: true\n              }\n\n              switch (exchangeName) {\n                case 'hitbtc':\n                  // console.log(\"HITBTC\");\n                  fees.hitbtc = parseFloat(taker_maker.maker) * 100\n                  break\n                case 'bittrex':\n                  fees.bittrex = parseFloat(taker_maker.maker) * 100\n                  break\n                case 'poloniex':\n                  fees.poloniex = parseFloat(taker_maker.maker) * 100\n                  break\n                case 'cobinhood':\n                  fees.cobinhood = parseFloat(taker_maker.maker) * 100\n                  break\n                case 'anybits':\n                  fees.anybits = parseFloat(taker_maker.maker) * 100\n                  break\n                case 'bitsane':\n                  fees.bitsane = parseFloat(taker_maker.maker) * 100\n                  break\n                case 'bleutrade':\n                  fees.bleutrade = parseFloat(taker_maker.maker) * 100\n                  break\n                case 'buda':\n                  fees.buda = parseFloat(taker_maker.maker) * 100\n                  break\n                case 'crex24':\n                  fees.crex24 = parseFloat(taker_maker.maker) * 100\n                  break\n                case 'livecoin':\n                  fees.livecoin = parseFloat(taker_maker.maker) * 100\n                  break\n                case 'kraken':\n                  fees.kraken = parseFloat(taker_maker.maker) * 100\n                  break\n                case 'binance':\n                  fees.binance = parseFloat(taker_maker.maker) * 100\n                  break\n\n                  // need to add other exchanges, but for now just these\n              }\n              // req.log.info(fees);\n              res.json(fees)\n            } else {\n              var fees = {\n                hitbtc: '0.1',\n                bittrex: '0.25',\n                poloniex: '0.2',\n                cobinhood: '0.0',\n                binance: '0.1',\n                anybits: '0.25',\n                bitsane: '0.2',\n                bleutrade: '0.25',\n                buda: '0.8',\n                crex24: '0.1',\n                livecoin: '0.18',\n                kraken: '0.26',\n                percentages: true\n              }\n              res.json(fees)\n            }\n          } catch (e) {\n            var fees = {\n              hitbtc: '0.1',\n              bittrex: '0.25',\n              poloniex: '0.2',\n              cobinhood: '0.0',\n              binance: '0.1',\n              anybits: '0.25',\n              bitsane: '0.2',\n              bleutrade: '0.25',\n              buda: '0.8',\n              crex24: '0.1',\n              livecoin: '0.18',\n              kraken: '0.26',\n              percentages: true\n            }\n            res.json(fees)\n          }\n        }\n      } else {\n        var error = {\n          error: true,\n          message: 'not able to get exchange',\n          stack: '-'\n        }\n        console.log('-------------------------')\n        req.log.error(error)\n        console.log('-------------------------')\n        res.json(error)\n      }\n    } catch (e) {\n      console.log('-------------------------')\n      req.log.error(e.stack)\n      console.log('-------------------------')\n      var error = {\n        error: true,\n        message: e\n      }\n      res.json(error)\n      // next(e)\n    }*/\n});\n\n// localhost/getOrders?exchange={}&baseCur={}&quoteCurr={}\napp.get(\"/getIsPaymentIDRequired\", async (req, res, next) => {\n  // var headers = JSON.parse(req.headers.credentials)\n  try {\n    parkersFunction.getIsCoinPaymentID(\n      function (inf) {\n        const coinIDCol = [];\n\n        for (var x in inf) {\n          const coin_inf = inf[x];\n          let paymentID_check = false;\n          if (\n            coin_inf.payinPaymentId === true ||\n            coin_inf.payoutIsPaymentId === true\n          ) {\n            paymentID_check = true;\n          }\n          const coinID = {\n            isPaymentID: paymentID_check,\n            isOutPaymentID: coin_inf.payoutIsPaymentId,\n            isInPaymentID: coin_inf.payinPaymentId,\n            symbol: coin_inf.id,\n          };\n\n          coinIDCol.push(coinID);\n        }\n\n        res.json(coinIDCol);\n        // req.log.info(coinIDCol);\n      },\n      function (err) {\n        console.log(\"-------------------------\");\n        req.log.error(err.stack);\n        console.log(\"-------------------------\");\n        // TODO handle the error\n\n        writeFile(\n          \"logs\\\\errorIsPaymentID\\\\errorIsPaymentID\",\n          err,\n          \"errorIsPaymentID\"\n        );\n        const error = {\n          error: true,\n          message: err,\n        };\n        res.json(error);\n      }\n    );\n  } catch (e) {\n    req.log.error(e);\n    // TODO handle the error\n    writeFile(\n      \"logs\\\\errorIsPaymentID\\\\errorIsPaymentID\",\n      e,\n      \"errorIsPaymentID\"\n    );\n    const error = {\n      error: true,\n      message: e,\n    };\n    res.json(error);\n    // next(e)\n  }\n});\n\n// localhost/getOrders?exchange={}&baseCur={}&quoteCurr={}\napp.get(\"/getOrderBooks\", async (req, res, next) => {\n  // var headers = JSON.parse(req.headers.credentials)\n  try {\n    const base_cur = req.query.baseCur;\n    const quote_cur = req.query.quoteCur;\n    const exchange = await getExchange(req.query.exchange); // , headers.apiKey, headers.apiSecret)\n    if (exchange !== null && exchange !== undefined) {\n      // console.log(headers);\n\n      const order = await exchange.fetchOrderBook(\n        req.query.baseCur + \"/\" + req.query.quoteCur\n      );\n      if (!optimized) {\n        writeFile(\n          \"logs\\\\getOrderBooks\\\\getOrderBooks\",\n          JSON.stringify(order),\n          \"getOrderBooks\"\n        );\n      }\n      // req.log.info(order);\n      res.json(order);\n    } else {\n      var error = {\n        error: true,\n        message: \"not able to get exchange\",\n        stack: \"-\",\n      };\n      console.log(\"-------------------------\");\n      req.log.error(error);\n      console.log(\"-------------------------\");\n      res.json(error);\n    }\n  } catch (e) {\n    req.log.error(e);\n    // TODO handle the error\n\n    writeFile(\"logs\\\\errorOrderBooks\\\\errorOrderBooks\", e, \"errorOrderBooks\");\n    var error = {\n      error: true,\n      message: e,\n    };\n    res.json(error);\n    // next(e)\n  }\n});\n\n// localhost/getDepositAddress?exchange={}&symbol={}\napp.get(\"/getDepositAddress\", async (req, res, next) => {\n  try {\n    const headers = JSON.parse(req.headers.credentials);\n    let exchange;\n    const exchangeName = req.query.exchange;\n    if (headers.password === undefined) {\n      if (headers.uid === undefined) {\n        exchange = await getExchange(\n          exchangeName,\n          headers.apiKey.trim(),\n          headers.apiSecret.trim()\n        );\n      } else {\n        exchange = await getExchange(\n          exchangeName,\n          headers.apiKey.trim(),\n          headers.apiSecret.trim(),\n          null,\n          headers.uid.trim()\n        );\n      }\n    } else {\n      exchange = await getExchange(\n        exchangeName,\n        headers.apiKey,\n        headers.apiSecret,\n        headers.password.trim()\n      );\n    }\n    if (exchange !== null && exchange !== undefined) {\n      const tradeID = req.headers.tradeid;\n      // addressDict = binanceapi.\n      // console.log(req.headers);\n      const order = await exchange.fetchDepositAddress(req.query.baseCur);\n      // req.log.info(order);\n      // console.log(tradeID);\n      if (tradeID !== undefined) {\n        if (!optimized) {\n          writeFile(\n            \"logs\\\\getDepositAddress\\\\getDepositAddress\",\n            JSON.stringify(order),\n            \"getDepositAddress\"\n          );\n        }\n      } else {\n        order.tradeID = tradeID;\n        // pino.info(tradeID)\n\n        if (!optimized) {\n          writeFile(\n            \"logs\\\\getDepositAddress\\\\getDepositAddress\",\n            JSON.stringify(order),\n            \"getDepositAddress\"\n          );\n        }\n      }\n      res.json(order);\n    } else {\n      var error = {\n        error: true,\n        message: \"not able to get exchange\",\n        stack: \"-\",\n      };\n      console.log(\"-------------------------\");\n      req.log.error(error);\n      console.log(\"-------------------------\");\n      res.json(error);\n    }\n  } catch (e) {\n    console.log(\"-------------------------\");\n    req.log.error(e.stack);\n    console.log(\"-------------------------\");\n    // TODO handle the error\n    writeFile(\"errorDepositAddress\", e, \"errorDepositAddress\");\n    var error = {\n      error: true,\n      message: e,\n    };\n    res.json(error);\n    // next(e)\n  }\n});\n\napp.get(\"/getWithdrawDepositFee\", async (req, res, next) => {\n  // var headers = JSON.parse(req.headers.credentials)\n  try {\n    // addressDict = binanceapi.\n    const exchange = req.query.exchange;\n    const base_cur = req.query.Currency;\n    if (exchange === \"binance\") {\n      console.log(\"-------------------------------creds-----\");\n      console.log(req.headers);\n      console.log(\"-----------------------------------------\");\n      const headers = JSON.parse(req.headers.credentials);\n      const withdrawOrDeposit = req.query.withOrDep;\n      console.log(\"parker:\");\n      console.log(parkersFunction);\n      await parkersFunction\n        .getWithdrawFeeAndActive(\n          exchange,\n          base_cur,\n          withdrawOrDeposit,\n          null,\n          headers.apiKey.trim(),\n          headers.apiSecret.trim()\n        )\n        .then(\n          function (success) {\n            try {\n              // console.log(\"withdraw response:\",success);\n              const data_fee = parkersFunction.parseData(\n                exchange,\n                success,\n                base_cur\n              );\n\n              // pino.info(\"------result---------------\");\n              // req.log.info(data_fee);\n              // pino.info(\"----------------------------\");\n              if (!optimized) {\n                writeFile(\n                  \"logs\\\\getWithdrawDepositFee\\\\getWithdrawDepositFee\",\n                  JSON.stringify(data_fee),\n                  \"getWithdrawDepositFee\"\n                );\n              }\n              res.json(data_fee);\n            } catch (e) {\n              const error = {\n                error: true,\n                message: e,\n              };\n\n              req.log.error(e);\n              res.json(error);\n            }\n          },\n          function (err) {\n            req.log.info(err);\n            res.json(err);\n          }\n        );\n    } else {\n      const withdrawOrDeposit = req.query.withOrDep;\n      await parkersFunction\n        .getWithdrawFeeAndActive(\n          exchange,\n          base_cur,\n          withdrawOrDeposit,\n          null,\n          null,\n          null\n        )\n        .then(\n          function (success) {\n            try {\n              // console.log(\"withdraw response:\",success);\n              const data_fee = parkersFunction.parseData(\n                exchange,\n                success,\n                base_cur\n              );\n              // pino.info(\"------result---------------\");\n              // req.log.info(data_fee);\n              // pino.info(\"----------------------------\");\n              if (!optimized) {\n                writeFile(\n                  \"logs\\\\getWithdrawDepositFee\\\\getWithdrawDepositFee\",\n                  JSON.stringify(data_fee),\n                  \"getWithdrawDepositFee\"\n                );\n              }\n              res.json(data_fee);\n            } catch (e) {\n              const error = {\n                error: true,\n                message: e,\n              };\n              console.log(\"catch error\");\n              req.log.error(e);\n              res.json(error);\n            }\n          },\n          function (err) {\n            console.log(\"big error\");\n            req.log.info(err);\n            res.json(err);\n          }\n        );\n    }\n\n    // res.json(data_fee_res);\n  } catch (e) {\n    console.log(\"-------------------------\");\n    req.log.error(e.stack);\n    console.log(\"-------------------------\");\n    writeFile(\n      \"logs\\\\errorWithdrawDepositFees\\\\errorWithdrawDepositFees\",\n      e,\n      \"errorWithdrawDepositFees\"\n    );\n    // TODO handle the error\n    const error = {\n      error: true,\n      message: e,\n    };\n    res.json(error);\n    // next(e)\n  }\n});\n\n// localhost/performWithdraw?exchange={}&symbol={}&amount={}&address={}&paymentID={}\napp.get(\"/performWithdraw\", async (req, res, next) => {\n  try {\n    const headers = JSON.parse(req.headers.credentials);\n    const tradeID = req.headers.tradeID;\n    let exchange;\n    if (headers.password === undefined) {\n      if (headers.uid === undefined) {\n        exchange = await getExchange(\n          req.query.exchange,\n          headers.apiKey.trim(),\n          headers.apiSecret.trim()\n        );\n      } else {\n        exchange = await getExchange(\n          req.query.exchange,\n          headers.apiKey.trim(),\n          headers.apiSecret.trim(),\n          null,\n          headers.uid.trim()\n        );\n      }\n    } else {\n      exchange = await getExchange(\n        req.query.exchange,\n        headers.apiKey,\n        headers.apiSecret,\n        headers.password.trim()\n      );\n    }\n    if (exchange !== null && exchange !== undefined) {\n      const address = req.headers.address;\n      // addressDict = binanceapi.\n      const amount = req.headers.amount;\n      let order;\n      if (headers.paymentID !== undefined) {\n        order = await exchange.withdraw(req.query.symbol, amount, address, {\n          paymentId: headers.paymentID,\n        });\n      } else {\n        order = await exchange.withdraw(req.query.symbol, amount, address);\n      }\n      // req.log.info(order);\n\n      if (tradeID !== undefined) {\n        order.tradeID = tradeID;\n        if (!optimized) {\n          writeFile(\n            \"logs\\\\performWithdraw\\\\performWithdraw\",\n            JSON.stringify(order),\n            \"performWithdraw\"\n          );\n        }\n      } else {\n        if (!optimized) {\n          writeFile(\n            \"logs\\\\perfromWithdraw\\\\performWithdraw\",\n            JSON.stringify(order),\n            \"performWithdraw\"\n          );\n        }\n      }\n      res.json(order);\n    } else {\n      var error = {\n        error: true,\n        message: \"not able to get exchange\",\n        stack: \"-\",\n      };\n      console.log(\"-------------------------\");\n      req.log.error(error);\n      console.log(\"-------------------------\");\n      res.json(error);\n    }\n  } catch (e) {\n    console.log(\"-------------------------\");\n    req.log.error(e.stack);\n    console.log(\"-------------------------\");\n    try {\n      writeFile(\n        \"logs\\\\errorPerformWithdraw\\\\errorPerformWithdraw\",\n        e,\n        \"errorPerformWithdraw\"\n      );\n    } catch (ee) {}\n    var error = {\n      error: true,\n      message: e,\n    };\n    res.json(error);\n    // next(e)\n  }\n});\n// localhost/getMarkets?exchange={}\napp.get(\"/getMarkets\", async (req, res, next) => {\n  // var headers = JSON.parse(req.headers.credentials, headers.apiKey, headers.apiSecret)\n  try {\n    const exchange = await getExchange(req.query.exchange);\n    if (exchange !== null && exchange !== undefined) {\n      const tradeID = req.headers.tradeID;\n      const markets = await exchange.fetchMarkets();\n      console.log(markets);\n      // addressDict = binanceapi.\n      // req.log.info(markets);\n      if (!optimized) {\n        writeFile(\"logs\\\\getMarkets\\\\getMarkets\", markets, \"getMarkets\");\n      }\n      res.json(markets);\n    } else {\n      var error = {\n        error: true,\n        message: \"not able to get exchange\",\n        stack: \"-\",\n      };\n      console.log(\"-------------------------\");\n      req.log.error(error);\n      console.log(\"-------------------------\");\n      res.json(error);\n    }\n  } catch (e) {\n    req.log.error(e);\n\n    writeFile(\"logs\\\\errorGetMarkets\\\\errorGetMarkets\", e, \"errorGetMarkets\");\n    var error = {\n      error: true,\n      message: e,\n    };\n    res.json(error);\n    // next(e);\n  }\n});\n\n// this needs work on\n// localhost/testExchange?exchange={}\napp.get(\"/testExchange\", async (req, res, next) => {\n  var headers = JSON.parse(\n    req.headers.credentials,\n    headers.apiKey,\n    headers.apiSecret\n  );\n  const result_public = {\n    fetchMarkets: false,\n    fetchOrderBook: false,\n    fetchTicker: false,\n    fetchBalance: false,\n    successTotal: false,\n    error: {\n      Exception: null,\n    },\n    data: {\n      markets: null,\n      orderbook: null,\n      ticker: null,\n      balance: null,\n    },\n    exchange: \"string\",\n  };\n  try {\n    let exchange;\n    if (headers.password === undefined) {\n      if (headers.uid === undefined) {\n        exchange = await getExchange(\n          req.query.exchange,\n          headers.apiKey.trim(),\n          headers.apiSecret.trim()\n        );\n      } else {\n        exchange = await getExchange(\n          req.query.exchange,\n          headers.apiKey.trim(),\n          headers.apiSecret.trim(),\n          null,\n          headers.uid.trim()\n        );\n      }\n    } else {\n      exchange = await getExchange(\n        req.query.exchange,\n        headers.apiKey,\n        headers.apiSecret,\n        headers.password.trim()\n      );\n    }\n    // var inDetail = req.query.indetail;\n    // addressDict = binanceapi\n    result_public.exchange = req.query.exchange;\n\n    const markets = await exchange.fetchMarkets();\n    const orderbook = await exchange.fetchOpenOrders();\n    const ticker = await exchange.fetchTicker();\n    const balance = await exchange.fetchBalance();\n\n    if (markets !== null && markets !== undefined) {\n      result_public.fetchMarkets = true;\n      result_public.data.markets = markets;\n    }\n\n    if (orderbook !== null && orderbook !== undefined) {\n      result_public.fetchOrderBook = true;\n      result_public.data.orderbook = orderbook;\n    }\n\n    if (ticker !== null && ticker !== undefined) {\n      result_public.fetchTicker = true;\n      result_public.data.ticker = ticker;\n    }\n\n    if (balance !== null && balance !== undefined) {\n      result_public.fetchBalance = true;\n      result_public.data.balance = balance;\n    }\n    // var order = await exchange.withdraw(headers.symbol, headers.amount, headers.address, {\"paymentId\" : headers.paymentID})\n\n    console.log(result_public);\n    res.json(reult_public);\n  } catch (e) {\n    // TODO handle the error\n    console.log(e);\n    const error = {\n      error: true,\n      message: e,\n    };\n    res.json(error);\n    // next(e)\n  }\n});\n\nfunction parseBalance(bal, exchange, currency) {\n  const bal_ret = [];\n  const universal_bal_temp = {\n    CurrencyId: \"\",\n    Symbol: \"\",\n    Total: \"\",\n    Available: \"\",\n    Status: \"\",\n  };\n\n  var universal_bal = null;\n  var inf = null;\n\n  const info = bal.info;\n\n  switch (exchange) {\n    case \"binance\":\n      for (var x in info.balances) {\n        var inf = info.balances[x];\n        console.log(\"info: \", inf);\n        var universal_bal = {\n          CurrencyId: \" \",\n          Symbol: inf.asset,\n          Total: parseFloat(inf.locked) + parseFloat(inf.free),\n          Available: inf.free,\n          Status: \" \",\n        };\n        bal_ret.push(universal_bal);\n      }\n      return bal_ret;\n    case \"hitbtc\":\n      for (var z in info) {\n        var inf = info[z];\n        var total = parseFloat(inf.available) + parseFloat(inf.reserved);\n        var universal_bal = {\n          CurrencyId: \"\",\n          Symbol: inf.currency,\n          Total: total,\n          Available: inf.available,\n          Status: \"\",\n        };\n        bal_ret.push(universal_bal);\n      }\n      return bal_ret;\n    case \"bittrex\":\n      for (var x in info) {\n        var inf = info[x];\n        var universal_bal = {\n          CurrencyId: \"\",\n          Symbol: inf.Currency,\n          Total: inf.Balance,\n          Available: inf.Available,\n          Status: \"\",\n        };\n        bal_ret.push(universal_bal);\n      }\n\n      return bal_ret;\n    case \"poloniex\":\n      var curBal = info[currency];\n      var total = parseFloat(curBal.available) + parseFloat(curBal.onOrders);\n      var universal_bal = {\n        CurrencyId: \"\",\n        Symbol: currency,\n        Total: total,\n        Available: curBal.availble,\n        Status: \"\",\n      };\n      return universal_bal;\n    case \"livecoin\":\n      var arr = info;\n      var filtered = arr.filter(function (x) {\n        return x.currency === currency;\n      });\n\n      var total;\n      var available;\n      var btcValue;\n\n      for (var y in arr) {\n        const selArr = arr[y];\n        switch (selArr.type) {\n          case \"total\":\n            total = selArr.value;\n            break;\n          case \"available\":\n            available = selArr.value;\n            break;\n          case \"btcValue\":\n            btcValue = selArr.value;\n            break;\n        }\n      }\n\n      var universal_bal = {\n        CurrencyId: \"\",\n        Symbol: currency,\n        Total: total,\n        Available: availble,\n        Status: \"\",\n      };\n\n      return universal_bal;\n    case \"kraken\":\n      var dat = info.data;\n      var arr = dat.list;\n      var filtered = arr.filter(function (x) {\n        return x.currency === currency;\n      });\n\n      var available;\n      var total;\n      var trade;\n\n      for (var y in filtered) {\n        var inf = filtered[y];\n        switch (inf.type) {\n          case \"trade\":\n            trade = inf.balance;\n          case \"frozen\":\n            available = inf.frozen;\n        }\n      }\n      total = parseFloat(available) + parseFloat(trade);\n      var universal_bal = {\n        CurrencyId: \"\",\n        Symbol: currency,\n        Total: total,\n        Available: availble,\n        Status: \"\",\n      };\n\n      return universal_bal;\n    case \"exmo\":\n      var bal = info.balances;\n      var res = info.reserved;\n\n      var available = bal[currency];\n      var reseve = bal[currency];\n\n      var total = parseFloat(available) + parseFloat(reserve);\n\n      var universal_bal = {\n        CurrencyId: \"\",\n        Symbol: currency,\n        Total: total,\n        Available: availble,\n        Status: \"\",\n      };\n\n      return universal_bal;\n\n    case \"crex24\":\n      arr = info.Balances;\n      for (var x in arr) {\n        var obj = arr[x];\n        var total = parseFloat(InOrderBalances) + parseFloat(AvailableBalances);\n        universal_bal = {\n          CurrencyId: \"\",\n          Symbol: currency,\n          Total: total,\n          Available: obj.AvailableBalances,\n          Status: \"\",\n        };\n        bal_ret.push(universal_bal);\n      }\n      return bal_ret;\n\n    case \"cobinhood\":\n      arr = info.result;\n      for (var x in arr.balances) {\n        var obj = arr[x];\n        const ava = parseFloat(obj.total) - parseFloat(obj.on_order);\n        var universal_bal = {\n          CurrencyId: \"\",\n          Symbol: currency,\n          Total: total,\n          Available: ava,\n          Status: \"\",\n        };\n        bal_ret.push(universal_bal);\n      }\n      return bal_ret;\n    case \"buda\":\n      var arr = info.balances;\n      for (var x in arr) {\n        var obj = arr[x];\n        var universal_bal = {\n          CurrencyId: \"\",\n          Symbol: currency,\n          Total: obj.amount[0],\n          Available: obj.available_amount[0],\n          Status: \"\",\n        };\n        bal_ret.push(universal_bal);\n      }\n      return bal_ret;\n    case \"bleutrade\":\n      var arr = info.result;\n      for (var x in arr) {\n        var obj = arr[x];\n        var universal_bal = {\n          CurrencyId: \"\",\n          Symbol: currency,\n          Total: obj.Balance,\n          Available: obj.Available,\n          Status: \"\",\n        };\n        bal_ret.push(universal_bal);\n      }\n      return bal_ret;\n\n    case \"bitsane\":\n      var arr = info.result;\n      var obj = arr[currency];\n      var universal_bal = {\n        CurrencyId: \"\",\n        Symbol: currency,\n        Total: obj.total,\n        Available: obj.amount,\n        Status: \"\",\n      };\n      bal_ret.push(universal_bal);\n      return bal_ret;\n\n    case \"bibox\":\n      var ob = info.result;\n      var arr = ob.assets_list;\n      for (var x in arr) {\n        var obj = arr[x];\n        var total = parseFloat(obj.balance) + parseFloat(obj.freeze);\n        var universal_bal = {\n          CurrencyId: \"\",\n          Symbol: currency,\n          Total: total,\n          Available: obj.amount,\n          Status: \"\",\n        };\n        bal_ret.push(universal_bal);\n      }\n\n      return bal_ret;\n    case \"anybits\":\n      var ob = info.result;\n      var arr = ob.assets_list;\n      for (var x in arr) {\n        var obj = arr[x];\n        var universal_bal = {\n          CurrencyId: \"\",\n          Symbol: currency,\n          Total: 0,\n          Available: obj.amount,\n          Status: \"\",\n        };\n        bal_ret.push(universal_bal);\n      }\n\n      return bal_ret;\n  }\n\n  return null;\n}\n\napp.get(\"/checkExchange\", async (req, res, next) => {\n  try {\n    const exchange = await getExchange(req.query.exchange);\n    const test = await exchange.fetchMarkets();\n    if (test !== undefined) {\n      res.json(test);\n      // req.log.info(test);\n    }\n  } catch (e) {\n    // console.log(\"-------------------------\")\n    req.log.error(e);\n    // console.log(\"-------------------------\")\n    res.json(\"[]\");\n  }\n});\n\nfunction inputPrompt(prompt, answerCallback) {\n  inquirer.prompt(prompt).then((answers) => {\n    answerCallback(answers);\n  });\n}\n\nvar workers = process.env.WORKERS || require(\"os\").cpus().length / 2;\nif (cluster.isMaster) {\n  var prompt = [\n    {\n      type: \"list\",\n      name: \"startup configuration\",\n      message: \"do you want cluster enabled (might disbale when debugging): \",\n      choices: [\"enabled\", \"disabled\"],\n    },\n    {\n      type: \"number\",\n      name: \"cores\",\n      message: \"(optinal) enter the number of clusters to run\",\n    },\n  ];\n\n  inputPrompt(prompt, function (info) {\n    var check = false;\n    console.log(info);\n    var numberWorkers = 0;\n    if (isNaN(info.cores)) {\n      numberWorkers = workers;\n    } else {\n      numberWorkers = info.cores;\n    }\n    if (info[\"startup configuration\"] === \"enabled\") {\n      check = true;\n    }\n    if (check === true) {\n      console.log(\"start cluster with %s workers\", numberWorkers);\n      for (var i = 0; i < numberWorkers; ++i) {\n        var worker = cluster.fork().process;\n        console.log(\"worker %s started.\", worker.pid);\n      }\n      cluster.on(\"exit\", function (worker) {\n        console.log(\"worker %s died. restart...\", worker.process.pid);\n        cluster.fork();\n      });\n    } else {\n      var worker = cluster.fork().process;\n    }\n  });\n} else {\n  app.listen(port, () =>\n    console.log(\n      `Example app listening on port ${port}!, optimzed is set:` + optimized\n    )\n  );\n  module.exports = app;\n}\n\nmodule.exports = server;\n\n//# sourceMappingURL=all.js.map\n\n//# sourceMappingURL=all.js.map\n\n//# sourceMappingURL=all.js.map\n\n//# sourceMappingURL=all.js.map\n\n//# sourceMappingURL=all.js.map\n"],"file":"all.js"}